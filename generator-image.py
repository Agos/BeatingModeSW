#!/usr/bin/python
# -*- coding: utf-8 -*-

from numpy import *
import Image
import pylab
import yaml
import os
import shutil
from matplotlib.colors import LinearSegmentedColormap

REPETITIONS = 60
PIXEL_F = 100.0
PIXEL_T = 1.0 / PIXEL_F
SHUTTER_F = 5.856
SHUTTER_T = 1.0 / (SHUTTER_F * 2.0)
H_STEP = 0.2
W_STEP = 0.2
MAX_RATIO = 5.0

# TODO: cambiare con lettura da file
# TODO: preparare per multiriga

segmentdata = {'red': [(0.0, 0.0, 0.0),
                       (1.0, 0.0, 0.0)],
               'green': [(0.0, 0.0, 0.0),
                         (1.0, 1.0, 1.0)],
               'blue': [(0.0, 0.0, 0.0),
                        (1.0, 0.0, 0.0)],
}

my_color_map = LinearSegmentedColormap("stdGreen", segmentdata)

input_data = array(Image.open("dati/rate.tiff")).astype('float')
rows, cols = input_data.shape[0], input_data.shape[1]
# Aggiungo le ripetizioni, do la forma definitiva all'array
input_data = input_data.repeat(REPETITIONS, 0)
input_data = input_data.reshape(rows, REPETITIONS, -1)

# TODO: aggiungere bleaching
er_data = array(Image.open("dati/ratio.tiff")).astype('float')
er_data = er_data.repeat(REPETITIONS, 0)
er_data = er_data.reshape(rows, REPETITIONS, -1)
scaling_factor = MAX_RATIO / er_data.max()
er_data = er_data * scaling_factor


def pixel_start(pos):
    return pos * PIXEL_T


def pixel_end(pos):
    return (pos + 1) * PIXEL_T

enhanced_data = empty_like(input_data)


for (row_n, row) in enumerate(input_data):
    if not row_n % 10:
        print row_n
    shape = row.shape
    row = row.flat
    enhanced_row = empty_like(row)
    er_row = er_data[row_n].flat
    # TODO: due passaggi, prima calcolo fasi, poi ripasso?
    for (pos, val) in ndenumerate(row):
        pos = pos[0]
        start = pixel_start(pos)
        end = pixel_end(pos)
        # Se non c'è transizione
        if start // SHUTTER_T == end // SHUTTER_T:
            # TODO: per capire on/off mi baso sul modulo due. Non è il massimo!
            if (start // SHUTTER_T) % 2:
                enhanced_row[pos] = val * er_row[pos]
            else:
                enhanced_row[pos] = val
        # Transizione
        else:
            phase_start = start % (SHUTTER_T)
            phase_end = end % (SHUTTER_T)
            # Durata totale del pixel. In realtà è inutile calcolarla
            total_phase = (1 - phase_end) + phase_start
            phase_before = (1 - phase_end)
            phase_after = phase_start
            enh_val = val * er_row[pos]
            # Acceso -> spento
            if (start // SHUTTER_T) % 2:
                enhanced_row[pos] = (phase_before / total_phase * enh_val +
                                     phase_after / total_phase * val)
            else:
                enhanced_row[pos] = (phase_before / total_phase * val +
                                     phase_after / total_phase * enh_val)
    enhanced_data[row_n] = enhanced_row.reshape(shape)
enhanced_data = enhanced_data.reshape(rows * REPETITIONS, cols)

pylab.imshow(enhanced_data)
pylab.show()

savetxt("out/generated.dat", enhanced_data, fmt="%10.5f", delimiter="\t")

metadata = {
    'Name': 'generated.dat',
    'acquired': 'generated by generator.py',
    'pixel_frequency': PIXEL_F,
    'repetitions': REPETITIONS,
    'shutter_frequency': SHUTTER_F,
    'h_step': H_STEP,
    'w_step': W_STEP,
}

inFile  = open('out/generated.dat', 'r')
outFile = open('out/temp.dat', 'w')
yaml.dump(metadata, outFile, default_flow_style=False)
outFile.write('---\n')
for line in inFile:
    outFile.write(line)
inFile.close()
outFile.close()
os.remove('out/generated.dat')
shutil.move('out/temp.dat', 'out/generated.dat')
